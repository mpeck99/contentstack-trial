{"version":3,"sources":["../../../../src/visualBuilder/utils/fieldSchemaMap.ts"],"sourcesContent":["import { has, isEqual } from \"lodash-es\";\nimport {\n    ISchemaFieldMap,\n    ISchemaIndividualFieldMap,\n} from \"./types/index.types\";\n\nimport visualBuilderPostMessage from \"./visualBuilderPostMessage\";\nimport { VisualBuilderPostMessageEvents } from \"./types/postMessage.types\";\n\ninterface IFieldSchemaMapResponse {\n    fieldSchemaMap: ISchemaIndividualFieldMap;\n}\n/**\n * Represents a cache for field schemas. Field schemas are\n * used to easily get the field schema based on the field\n * Cslp.\n */\nexport class FieldSchemaMap {\n    private static fieldSchema: {\n        [contentTypeUid: string]: ISchemaIndividualFieldMap;\n    } = {};\n\n    private static fieldSchemaPromise: {\n        [contentTypeUid: string]: Promise<IFieldSchemaMapResponse> | undefined;\n    } = {};\n\n    private static async fetchFieldSchema(content_type_uid: string) {\n        if (!FieldSchemaMap.fieldSchemaPromise?.[content_type_uid]) {\n            FieldSchemaMap.fieldSchemaPromise[content_type_uid] =\n                visualBuilderPostMessage?.send<IFieldSchemaMapResponse>(\n                    VisualBuilderPostMessageEvents.GET_FIELD_SCHEMA,\n                    {\n                        contentTypeUid: content_type_uid,\n                    }\n                );\n        }\n        return FieldSchemaMap.fieldSchemaPromise[content_type_uid];\n    }\n    /**\n     * Retrieves the schema field map for a given content type and field Cslp.\n     * @param contentTypeUid - The unique identifier of the content type.\n     * @param fieldCslp - The Cslp of the field.\n     * @returns The schema field map.\n     */\n    static async getFieldSchema(\n        contentTypeUid: string,\n        fieldCslp: string\n    ): Promise<ISchemaFieldMap> {\n        if (FieldSchemaMap.hasFieldSchema(contentTypeUid, fieldCslp)) {\n            return Promise.resolve(\n                FieldSchemaMap.fieldSchema[contentTypeUid][fieldCslp]\n            );\n        }\n\n        const data = await FieldSchemaMap.fetchFieldSchema(contentTypeUid);\n\n        if (data?.fieldSchemaMap) {\n            FieldSchemaMap.fieldSchema[contentTypeUid] = data.fieldSchemaMap;\n        }\n\n        return FieldSchemaMap?.fieldSchema?.[contentTypeUid]?.[fieldCslp] || null;\n    }\n\n    static hasFieldSchema(contentTypeUid: string, fieldCslp: string): boolean {\n        return has(FieldSchemaMap.fieldSchema, [contentTypeUid, fieldCslp]);\n    }\n\n    /**\n     * Checks if two field schemas are equal.\n     * @param firstFieldSchema - The first field schema to compare.\n     * @param secondFieldSchema - The second field schema to compare.\n     * @returns True if the field schemas are equal, false otherwise.\n     */\n    static areFieldSchemaEqual(\n        firstFieldSchema: ISchemaFieldMap,\n        secondFieldSchema: ISchemaFieldMap\n    ): boolean {\n        return isEqual(firstFieldSchema, secondFieldSchema);\n    }\n\n    /**\n     * Sets the field schema for a given content type.\n     * @param contentTypeUid The unique identifier of the content type.\n     * @param fieldSchemaMap The map of individual field schemas.\n     */\n    static setFieldSchema(\n        contentTypeUid: string,\n        fieldSchemaMap: ISchemaIndividualFieldMap\n    ): void {\n        FieldSchemaMap.fieldSchema[contentTypeUid] = fieldSchemaMap;\n    }\n\n    /**\n     * Clears the field schema cache.\n     */\n    static clear(): void {\n        FieldSchemaMap.fieldSchema = {};\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAA6B;AAM7B,sCAAqC;AACrC,yBAA+C;AAUxC,IAAM,kBAAN,MAAM,gBAAe;AAAA,EASxB,aAAqB,iBAAiB,kBAA0B;AA1BpE;AA2BQ,QAAI,GAAC,qBAAe,uBAAf,mBAAoC,oBAAmB;AACxD,sBAAe,mBAAmB,gBAAgB,KAC9C,qCAAAA,YAAA,mBAA0B;AAAA,QACtB,kDAA+B;AAAA,QAC/B;AAAA,UACI,gBAAgB;AAAA,QACpB;AAAA;AAAA,IAEZ;AACA,WAAO,gBAAe,mBAAmB,gBAAgB;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,eACT,gBACA,WACwB;AA/ChC;AAgDQ,QAAI,gBAAe,eAAe,gBAAgB,SAAS,GAAG;AAC1D,aAAO,QAAQ;AAAA,QACX,gBAAe,YAAY,cAAc,EAAE,SAAS;AAAA,MACxD;AAAA,IACJ;AAEA,UAAM,OAAO,MAAM,gBAAe,iBAAiB,cAAc;AAEjE,QAAI,6BAAM,gBAAgB;AACtB,sBAAe,YAAY,cAAc,IAAI,KAAK;AAAA,IACtD;AAEA,aAAO,8DAAgB,gBAAhB,mBAA8B,oBAA9B,mBAAgD,eAAc;AAAA,EACzE;AAAA,EAEA,OAAO,eAAe,gBAAwB,WAA4B;AACtE,eAAO,sBAAI,gBAAe,aAAa,CAAC,gBAAgB,SAAS,CAAC;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,oBACH,kBACA,mBACO;AACP,eAAO,0BAAQ,kBAAkB,iBAAiB;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,eACH,gBACA,gBACI;AACJ,oBAAe,YAAY,cAAc,IAAI;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,QAAc;AACjB,oBAAe,cAAc,CAAC;AAAA,EAClC;AACJ;AAjFa,gBACM,cAEX,CAAC;AAHI,gBAKM,qBAEX,CAAC;AAPF,IAAM,iBAAN;","names":["visualBuilderPostMessage"]}