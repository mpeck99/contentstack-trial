{"version":3,"sources":["../../../../src/visualBuilder/utils/multipleElementAddButton.ts"],"sourcesContent":["import { VisualBuilderCslpEventDetails } from \"../types/visualBuilder.types\";\nimport {\n    generateAddInstanceButton,\n    getAddInstanceButtons,\n} from \"../generators/generateAddInstanceButtons\";\nimport visualBuilderPostMessage from \"./visualBuilderPostMessage\";\nimport { VisualBuilderPostMessageEvents } from \"./types/postMessage.types\";\nimport getChildrenDirection from \"./getChildrenDirection\";\nimport { hideOverlay } from \"../generators/generateOverlay\";\nimport { hideHoverOutline } from \"../listeners/mouseHover\";\nimport { ISchemaFieldMap } from \"./types/index.types\";\n\nconst WAIT_FOR_NEW_INSTANCE_TIMEOUT = 4000;\n\n/**\n * The function that handles the add instance buttons for multiple fields.\n * @param eventDetails The details containing the field metadata and cslp value.\n * @param elements The elements object that contain the editable element and visual builder wrapper.\n * @param config The configuration object that contains the expected field data and disabled state.\n * @returns void\n */\nexport function handleAddButtonsForMultiple(\n    eventDetails: VisualBuilderCslpEventDetails,\n    elements: {\n        editableElement: Element | null;\n        visualBuilderContainer: HTMLDivElement | null;\n        resizeObserver: ResizeObserver;\n    },\n    config: {\n        fieldSchema: ISchemaFieldMap;\n        /**\n         * expectedFieldData is the value of the whole multiple field (an array)\n         */\n        expectedFieldData: any;\n        disabled: boolean;\n        label: string | undefined;\n    }\n): void {\n    const { editableElement, visualBuilderContainer, resizeObserver } =\n        elements;\n    const { expectedFieldData, fieldSchema, disabled, label } = config;\n\n    const parentCslpValue =\n        eventDetails.fieldMetadata.multipleFieldMetadata?.parentDetails\n            ?.parentCslpValue;\n\n    if (!editableElement || !parentCslpValue) {\n        return;\n    }\n\n    const direction = getChildrenDirection(editableElement, parentCslpValue);\n    if (direction === \"none\" || !visualBuilderContainer) {\n        return;\n    }\n\n    const targetDOMDimension = editableElement.getBoundingClientRect();\n    removeAddInstanceButtons(\n        {\n            visualBuilderContainer: visualBuilderContainer,\n            eventTarget: null,\n            overlayWrapper: null,\n        },\n        true\n    );\n\n    const overlayWrapper = visualBuilderContainer.querySelector(\n        \".visual-builder__overlay__wrapper\"\n    );\n    const focusedToolbar = visualBuilderContainer.querySelector(\n        \".visual-builder__focused-toolbar\"\n    );\n\n    const hideOverlayAndHoverOutline = () => {\n        hideHoverOutline(visualBuilderContainer);\n        hideOverlay({\n            visualBuilderContainer: visualBuilderContainer,\n            visualBuilderOverlayWrapper: overlayWrapper as HTMLDivElement,\n            focusedToolbar: focusedToolbar as HTMLDivElement,\n            resizeObserver,\n        });\n    };\n\n    if (disabled) {\n        return;\n    }\n\n    // is whole field and not a single instance of the multiple field\n    const isField =\n        eventDetails.fieldMetadata.instance.fieldPathWithIndex ===\n        eventDetails.fieldMetadata.fieldPathWithIndex;\n\n    const prevIndex = isField\n        ? 0\n        : eventDetails.fieldMetadata.multipleFieldMetadata.index;\n    const nextIndex = isField\n        ? expectedFieldData.length\n        : eventDetails.fieldMetadata.multipleFieldMetadata.index + 1;\n\n    const parentCslp = isField ? eventDetails.cslpData : parentCslpValue;\n\n    const onMessageSent = (index: number) => {\n        hideOverlayAndHoverOutline();\n        observeParentAndFocusNewInstance({\n            parentCslp,\n            index,\n        });\n    };\n\n    const previousButton = generateAddInstanceButton({\n        onClick: () => {\n            visualBuilderPostMessage\n                ?.send(VisualBuilderPostMessageEvents.ADD_INSTANCE, {\n                    fieldMetadata: eventDetails.fieldMetadata,\n                    index: prevIndex,\n                })\n                .then(onMessageSent.bind(null, prevIndex));\n        },\n        label,\n        fieldSchema,\n        value: expectedFieldData,\n    });\n\n    const nextButton = generateAddInstanceButton({\n        onClick: () => {\n            visualBuilderPostMessage\n                ?.send(VisualBuilderPostMessageEvents.ADD_INSTANCE, {\n                    fieldMetadata: eventDetails.fieldMetadata,\n                    index: nextIndex,\n                })\n                .then(onMessageSent.bind(null, nextIndex));\n        },\n        label,\n        fieldSchema,\n        value: expectedFieldData,\n    });\n\n    if (!visualBuilderContainer.contains(previousButton)) {\n        visualBuilderContainer.appendChild(previousButton);\n    }\n\n    if (!visualBuilderContainer.contains(nextButton)) {\n        visualBuilderContainer.appendChild(nextButton);\n    }\n\n    if (direction === \"horizontal\") {\n        const middleHeight =\n            targetDOMDimension.top +\n            (targetDOMDimension.bottom - targetDOMDimension.top) / 2 +\n            window.scrollY;\n        previousButton.style.left = `${targetDOMDimension.left}px`;\n        previousButton.style.top = `${middleHeight}px`;\n\n        nextButton.style.left = `${targetDOMDimension.right}px`;\n        nextButton.style.top = `${middleHeight}px`;\n    } else {\n        const middleWidth =\n            targetDOMDimension.left +\n            (targetDOMDimension.right - targetDOMDimension.left) / 2;\n        previousButton.style.left = `${middleWidth}px`;\n        previousButton.style.top = `${\n            targetDOMDimension.top + window.scrollY\n        }px`;\n\n        nextButton.style.left = `${middleWidth}px`;\n        nextButton.style.top = `${\n            targetDOMDimension.bottom + window.scrollY\n        }px`;\n    }\n}\n\nexport function removeAddInstanceButtons(\n    elements: {\n        visualBuilderContainer: HTMLDivElement | null;\n        overlayWrapper: HTMLDivElement | null;\n        eventTarget: EventTarget | null;\n    },\n    forceRemoveAll = false\n): void {\n    const { visualBuilderContainer, overlayWrapper, eventTarget } = elements;\n\n    if (!visualBuilderContainer) {\n        return;\n    }\n\n    if (forceRemoveAll) {\n        const addInstanceButtons = getAddInstanceButtons(\n            visualBuilderContainer,\n            true\n        );\n\n        addInstanceButtons?.forEach((button) => button.remove());\n    }\n\n    const addInstanceButtons = getAddInstanceButtons(visualBuilderContainer);\n\n    if (!addInstanceButtons) {\n        return;\n    }\n\n    const [previousButton, nextButton] = addInstanceButtons;\n\n    if (overlayWrapper?.classList.contains(\"visible\")) {\n        return;\n    }\n\n    if (\n        eventTarget &&\n        (previousButton.contains(eventTarget as Node) ||\n            nextButton.contains(eventTarget as Node))\n    ) {\n        return;\n    }\n\n    nextButton.remove();\n    previousButton.remove();\n}\n\n/**\n * This function that observes the parent element and focuses the newly added instance.\n *\n * @param parentCslp The parent cslp value.\n * @param index The index of the new instance.\n * @returns void\n *\n * We can evolve the retry logic, as different use cases arise.\n * Currently, if the new element is not found after the first mutation, we until\n * WAIT_FOR_NEW_INSTANCE_TIMEOUT, expecting that the new instance/block will be\n * found in later mutations and we can focus + disconnect then.\n * We also ensure there is only one setTimeout scheduled.\n */\nexport function observeParentAndFocusNewInstance({\n    parentCslp,\n    index,\n}: {\n    parentCslp: string;\n    index: number;\n}): void {\n    const parent = document.querySelector(\n        `[data-cslp='${parentCslp}']`\n    ) as HTMLElement;\n\n    if (parent) {\n        const expectedCslp = [parentCslp, index].join(\".\");\n\n        let hasObserverDisconnected = false;\n        let timeoutId: ReturnType<typeof setTimeout> | null = null;\n\n        const mutationObserver = new MutationObserver(\n            (_mutations, observer) => {\n                const newInstance = parent.querySelector(\n                    `[data-cslp='${expectedCslp}']`\n                ) as HTMLElement | null;\n                if (newInstance) {\n                    // this is how we also navigate to parent elements, but parent elements\n                    // are never primitive fields, the instances can be and this steals\n                    // focus from the form and puts it on the canvas.\n                    // So currently for a singleline multiple field, the form opens but we\n                    // come back to the canvas.\n                    // TODO - maybe we should not focus the content-editable\n                    // TODO - temp fix. We remove our empty block div once the new block arrives\n                    // but we focus the element before that and then the block shifts.\n                    // For some reason, the window resize event also does not trigger\n                    setTimeout(() => newInstance.click(), 350);\n                    observer.disconnect();\n                    hasObserverDisconnected = true;\n                    return;\n                }\n                if (!hasObserverDisconnected && !timeoutId) {\n                    // disconnect the observer whether we found the new instance or not\n                    // after timeout\n                    timeoutId = setTimeout(() => {\n                        observer.disconnect();\n                        hasObserverDisconnected = false;\n                    }, WAIT_FOR_NEW_INSTANCE_TIMEOUT);\n                }\n            }\n        );\n        mutationObserver.observe(parent, {\n            childList: true,\n            // watch subtrees as there may be wrapper elements\n            subtree: true,\n            // we don't need to watch for attribute changes\n            attributes: false,\n        });\n    }\n}\n"],"mappings":"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","names":["getChildrenDirection","_a","visualBuilderPostMessage","addInstanceButtons"]}